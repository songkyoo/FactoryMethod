using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using static Macaron.FactoryMethod.Helpers;
using static Microsoft.CodeAnalysis.Accessibility;

namespace Macaron.FactoryMethod;

[Generator]
public sealed class FactoryMethodGenerator : IIncrementalGenerator
{
    #region Constants
    private const string AutoFactoryAttributeSource =
        """
        // <auto-generated/>
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.FactoryMethod
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor, Inherited = false, AllowMultiple = false)]
            internal sealed class AutoFactoryAttribute : Attribute
            {
                public string MethodName { get; }

                public AutoFactoryAttribute()
                {
                    MethodName = "";
                }

                public AutoFactoryAttribute(string methodName)
                {
                    MethodName = methodName;
                }
            }
        }
        """;

    private const string IgnoreAutoFactoryAttributeSource =
        """
        // <auto-generated/>
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.FactoryMethod
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Constructor, Inherited = false, AllowMultiple = false)]
            internal sealed class IgnoreAutoFactoryAttribute : Attribute
            {
            }
        }
        """;
    #endregion

    #region Static Methods
    private static void AddSource(
        SourceProductionContext context,
        INamedTypeSymbol typeSymbol,
        Func<INamedTypeSymbol, ImmutableArray<string>> generateSourceCode
    )
    {
        var lines = generateSourceCode(typeSymbol);
        if (lines.IsEmpty)
        {
            return;
        }

        var stringBuilder = CreateStringBuilderWithFileHeader();

        // begin namespace
        var hasNamespace = !typeSymbol.ContainingNamespace.IsGlobalNamespace;
        if (hasNamespace)
        {
            stringBuilder.AppendLine($"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
            stringBuilder.AppendLine($"{{");
        }

        // get nestedTypes
        var nestedTypes = new List<INamedTypeSymbol>();
        var parentType = typeSymbol.ContainingType;
        while (parentType != null)
        {
            nestedTypes.Add(parentType);
            parentType = parentType.ContainingType;
        }

        var depthSpacerText = hasNamespace ? "    " : "";

        // begin nestedTypes
        for (var i = nestedTypes.Count - 1; i >= 0; --i)
        {
            var nestedType = nestedTypes[i];

            stringBuilder.AppendLine($"{depthSpacerText}{GetPartialTypeDeclarationString(nestedType)}");
            stringBuilder.AppendLine($"{depthSpacerText}{{");

            depthSpacerText += "    ";
        }

        // begin containingType
        stringBuilder.AppendLine($"{depthSpacerText}{GetPartialTypeDeclarationString(typeSymbol)}");
        stringBuilder.AppendLine($"{depthSpacerText}{{");

        // generate factory methods
        depthSpacerText += "    ";

        foreach (var line in lines)
        {
            stringBuilder.AppendLine($"{(line.Length > 0 ? depthSpacerText : "")}{line}");
        }

        depthSpacerText = depthSpacerText[..^4];

        // end containedType
        stringBuilder.AppendLine($"{depthSpacerText}}}");

        // end nestedTypes
        for (var i = 0; i < nestedTypes.Count; ++i)
        {
            depthSpacerText = depthSpacerText[..^4];

            stringBuilder.AppendLine($"{depthSpacerText}}}");
        }

        // end namespace
        if (hasNamespace)
        {
            stringBuilder.AppendLine($"}}");
        }

        context.AddSource(
            hintName: GetHintName(typeSymbol),
            sourceText: SourceText.From(stringBuilder.ToString(), Encoding.UTF8)
        );
    }

    private static ImmutableArray<string> GenerateFactoryMethodCode(INamedTypeSymbol typeSymbol)
    {
        var (hasTypeAttribute, defaultMethodName) = GetTypeContext(typeSymbol);
        var staticMethodSymbols = typeSymbol
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Where(methodSymbol => methodSymbol.IsStatic)
            .GroupBy(static methodSymbol => methodSymbol.Name)
            .ToImmutableDictionary(
                keySelector: group => group.Key,
                elementSelector: group => group.ToImmutableArray()
            );

        var builder = ImmutableArray.CreateBuilder<string>();
        foreach (var methodSymbol in FilterTargetConstructors(typeSymbol, hasTypeAttribute))
        {
            var parameters = methodSymbol.Parameters;
            var paramList = string.Join(", ", parameters.Select(GetParameterString));
            var argList = string.Join(", ", parameters.Select(GetArgumentString));

            var attributeData = methodSymbol
                .GetAttributes()
                .FirstOrDefault(attributeData => IsAutoFactoryAttribute(attributeData.AttributeClass));
            var methodName = TryGetGeneratedFactoryMethodName(attributeData, out var methodName2)
                ? methodName2
                : defaultMethodName;
            var accessModifier = methodSymbol.DeclaredAccessibility == Private
                ? "public"
                : methodSymbol.DeclaredAccessibility.ToString().ToLowerInvariant(); // public or internal

            if (HasDuplicatedMethodSignature(staticMethodSymbols, methodName, parameters))
            {
                continue;
            }

            var method = $"{accessModifier} static {typeSymbol.Name} {methodName}({paramList}) => new({argList});";

            if (builder.Count > 0)
            {
                builder.Add("");
            }

            builder.Add($"{method}");
        }

        return builder.ToImmutable();

        #region Local Functions
        static IEnumerable<IMethodSymbol> FilterTargetConstructors(INamedTypeSymbol typeSymbol, bool hasTypeAttribute)
        {
            return typeSymbol
                .InstanceConstructors
                .Where(methodSymbol => methodSymbol.Parameters.Length > 0)
                .Where(methodSymbol =>
                {
                    if (HasIgnoreAutoFactoryAttribute(methodSymbol))
                    {
                        return false;
                    }

                    var declaredAccessibility = methodSymbol.DeclaredAccessibility;

                    if (hasTypeAttribute)
                    {
                        return
                            declaredAccessibility is Public or Internal ||
                            (declaredAccessibility is Private && HasAutoFactoryAttribute(methodSymbol));
                    }
                    else
                    {
                        return
                            declaredAccessibility is Public or Internal &&
                            HasAutoFactoryAttribute(methodSymbol);
                    }
                });
        }

        static bool HasDuplicatedMethodSignature(
            ImmutableDictionary<string, ImmutableArray<IMethodSymbol>> candidates,
            string methodName,
            ImmutableArray<IParameterSymbol> parameterSymbols
        )
        {
            if (!candidates.TryGetValue(methodName, out var methodSymbols))
            {
                return false;
            }

            return methodSymbols.Any(methodSymbol =>
            {
                var comparer = SymbolEqualityComparer.Default;
                var targetParameterSymbols = methodSymbol.Parameters;

                if (parameterSymbols.Length != targetParameterSymbols.Length)
                {
                    return false;
                }

                for (var i = 0; i < targetParameterSymbols.Length; i++)
                {
                    var paramSymbol1 = parameterSymbols[i];
                    var paramSymbol2 = targetParameterSymbols[i];

                    if (!comparer.Equals(paramSymbol1.Type, paramSymbol2.Type))
                    {
                        return false;
                    }

                    if (paramSymbol1.RefKind != paramSymbol2.RefKind)
                    {
                        return false;
                    }

                    if (paramSymbol1.IsParams != paramSymbol2.IsParams)
                    {
                        return false;
                    }
                }

                return true;
            });
        }
        #endregion
    }

    private static StringBuilder CreateStringBuilderWithFileHeader()
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("// <auto-generated />");
        stringBuilder.AppendLine("#nullable enable");
        stringBuilder.AppendLine();

        return stringBuilder;
    }

    private static string GetPartialTypeDeclarationString(INamedTypeSymbol typeSymbol)
    {
        var typeKind = GetTypeKindString(typeSymbol);
        var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        return $"partial {typeKind} {typeName}";
    }

    private static string GetTypeKindString(INamedTypeSymbol typeSymbol)
    {
        if (typeSymbol.IsRecord)
        {
            return typeSymbol.TypeKind is TypeKind.Struct ? "record struct" : "record" ;
        }

        return typeSymbol.TypeKind switch
        {
            TypeKind.Class => "class",
            TypeKind.Struct => "struct",
            TypeKind.Interface => "interface",
            _ => throw new InvalidOperationException($"Invalid type kind: {typeSymbol.TypeKind}")
        };
    }

    private static string GetHintName(INamedTypeSymbol typeSymbol)
    {
        var assemblyName = typeSymbol.ContainingAssembly != null ? $"{typeSymbol.ContainingAssembly}," : "";
        var qualifiedName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        const uint fnvPrime = 16777619;
        const uint offsetBasis = 2166136261;

        var bytes = Encoding.UTF8.GetBytes($"{assemblyName}, {qualifiedName}");
        uint hash = offsetBasis;

        foreach (var b in bytes)
        {
            hash ^= b;
            hash *= fnvPrime;
        }

        return $"{typeSymbol.Name}_{typeSymbol.Arity}.{hash:x8}.g.cs";
    }

    private static INamedTypeSymbol? GetTypeTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is not TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return null;
        }

        if (!GetAttributes(typeDeclarationSyntax)
            .Select(GetMethodSymbol)
            .Select(methodSymbol => methodSymbol?.ContainingType)
            .Any(IsAutoFactoryAttribute)
        )
        {
            return null;
        }

        return context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax);

        #region Local Functions
        static IEnumerable<AttributeSyntax> GetAttributes(TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return typeDeclarationSyntax.AttributeLists.SelectMany(attrList => attrList.Attributes);
        }

        IMethodSymbol? GetMethodSymbol(AttributeSyntax attributeSyntax)
        {
            return context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;
        }
        #endregion
    }

    private static INamedTypeSymbol? GetConstructorTarget(GeneratorSyntaxContext context)
    {
        var node = (ConstructorDeclarationSyntax)context.Node;
        return context.SemanticModel.GetDeclaredSymbol(node)?.ContainingType;
    }
    #endregion

    #region IIncrementalGenerator Interface
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                hintName: "AutoFactoryAttribute.g.cs",
                sourceText: SourceText.From(AutoFactoryAttributeSource, Encoding.UTF8)
            );
            ctx.AddSource(
                hintName: "IgnoreAutoFactoryAttribute.g.cs",
                sourceText: SourceText.From(IgnoreAutoFactoryAttributeSource, Encoding.UTF8)
            );
        });

        var typeTargets = context
            .SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _) => syntaxNode is TypeDeclarationSyntax
                {
                    AttributeLists.Count: > 0
                },
                transform: static (generatorSyntaxContext, _) => GetTypeTarget(generatorSyntaxContext)
            )
            .Where(static namedTypeSymbol => namedTypeSymbol is not null);

        var constructorTargets = context
            .SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _) => syntaxNode is ConstructorDeclarationSyntax
                {
                    AttributeLists.Count: > 0
                },
                transform: static (generatorSyntaxContext, _) => GetConstructorTarget(generatorSyntaxContext)
            )
            .Where(static namedTypeSymbol => namedTypeSymbol is not null);


        var valueProvider = typeTargets.Collect().Combine(constructorTargets.Collect()).Select((tuple, _) =>
        {
            var (typeSymbols1, typeSymbols2) = tuple;
            return typeSymbols1
                .Concat(typeSymbols2)
                .Distinct(SymbolEqualityComparer.Default)
                .Cast<INamedTypeSymbol>()
                .ToImmutableArray();
        });

        context.RegisterSourceOutput(valueProvider, (sourceProductionContext, typeSymbols) =>
        {
            foreach (var typeSymbol in typeSymbols)
            {
                AddSource(sourceProductionContext, typeSymbol, GenerateFactoryMethodCode);
            }
        });
    }
    #endregion
}
