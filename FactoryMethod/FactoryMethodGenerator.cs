using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using static Macaron.FactoryMethod.ParameterStringHelpers;
using static Macaron.FactoryMethod.SourceGenerationHelpers;
using static Microsoft.CodeAnalysis.Accessibility;

namespace Macaron.FactoryMethod;

[Generator]
public sealed class FactoryMethodGenerator : IIncrementalGenerator
{
    #region Constants
    private const string AutoFactoryAttributeSource =
        """
        // <auto-generated/>
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.FactoryMethod
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor, Inherited = false, AllowMultiple = false)]
            internal sealed class AutoFactoryAttribute : Attribute
            {
                public string MethodName { get; }

                public AutoFactoryAttribute(string methodName = "")
                {
                    MethodName = methodName;
                }
            }
        }

        """;
    private const string IgnoreAutoFactoryAttributeSource =
        """
        // <auto-generated/>
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.FactoryMethod
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Constructor, Inherited = false, AllowMultiple = false)]
            internal sealed class IgnoreAutoFactoryAttribute : Attribute
            {
            }
        }

        """;

    private const string AutoFactoryAttributeString = "Macaron.FactoryMethod.AutoFactoryAttribute";
    private const string IgnoreAutoFactoryAttributeString = "Macaron.FactoryMethod.IgnoreAutoFactoryAttribute";

    private const string DefaultMethodName = "Of";
    #endregion

    #region Static Methods
    private static INamedTypeSymbol? GetTypeTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is not TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return null;
        }

        if (!GetAttributes(typeDeclarationSyntax)
            .Select(GetMethodSymbol)
            .Select(methodSymbol => methodSymbol?.ContainingType)
            .Any(IsAutoFactoryAttribute)
        )
        {
            return null;
        }

        return context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax);

        #region Local Functions
        static IEnumerable<AttributeSyntax> GetAttributes(TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return typeDeclarationSyntax.AttributeLists.SelectMany(attrList => attrList.Attributes);
        }

        IMethodSymbol? GetMethodSymbol(AttributeSyntax attributeSyntax)
        {
            return context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;
        }
        #endregion
    }

    private static INamedTypeSymbol? GetConstructorTarget(GeneratorSyntaxContext context)
    {
        var node = (ConstructorDeclarationSyntax)context.Node;
        return context.SemanticModel.GetDeclaredSymbol(node)?.ContainingType;
    }

    private static ImmutableArray<string> GenerateFactoryMethodCode(INamedTypeSymbol typeSymbol)
    {
        var (hasTypeAttribute, defaultMethodName) = GetTypeContext(typeSymbol);
        var staticMethodSymbols = typeSymbol
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Where(methodSymbol => methodSymbol.IsStatic)
            .GroupBy(static methodSymbol => methodSymbol.Name)
            .ToImmutableDictionary(
                keySelector: group => group.Key,
                elementSelector: group => group.ToImmutableArray()
            );

        var builder = ImmutableArray.CreateBuilder<string>();
        foreach (var methodSymbol in FilterTargetConstructors(typeSymbol, hasTypeAttribute))
        {
            var parameters = methodSymbol.Parameters;
            var paramList = string.Join(", ", parameters.Select(GetParameterString));
            var argList = string.Join(", ", parameters.Select(GetArgumentString));

            var attributeData = methodSymbol
                .GetAttributes()
                .FirstOrDefault(attributeData => IsAutoFactoryAttribute(attributeData.AttributeClass));
            var methodName = TryGetGeneratedFactoryMethodName(attributeData, out var methodName2)
                ? methodName2
                : defaultMethodName;
            var accessModifier = methodSymbol.DeclaredAccessibility == Private
                ? "public"
                : methodSymbol.DeclaredAccessibility.ToString().ToLowerInvariant(); // public or internal

            if (HasDuplicatedMethodSignature(staticMethodSymbols, methodName, parameters))
            {
                continue;
            }

            var method = $"{accessModifier} static {typeSymbol.Name} {methodName}({paramList}) => new({argList});";

            if (builder.Count > 0)
            {
                builder.Add("");
            }

            builder.Add($"{method}");
        }

        return builder.ToImmutable();

        #region Local Functions
        static IEnumerable<IMethodSymbol> FilterTargetConstructors(INamedTypeSymbol typeSymbol, bool hasTypeAttribute)
        {
            return typeSymbol
                .InstanceConstructors
                .Where(methodSymbol => methodSymbol.Parameters.Length > 0)
                .Where(methodSymbol =>
                {
                    if (HasIgnoreAutoFactoryAttribute(methodSymbol))
                    {
                        return false;
                    }

                    var declaredAccessibility = methodSymbol.DeclaredAccessibility;

                    if (hasTypeAttribute)
                    {
                        return
                            declaredAccessibility is Public or Internal ||
                            (declaredAccessibility is Private && HasAutoFactoryAttribute(methodSymbol));
                    }
                    else
                    {
                        return
                            declaredAccessibility is Public or Internal or Private &&
                            HasAutoFactoryAttribute(methodSymbol);
                    }
                });
        }

        static bool HasDuplicatedMethodSignature(
            ImmutableDictionary<string, ImmutableArray<IMethodSymbol>> candidates,
            string methodName,
            ImmutableArray<IParameterSymbol> parameterSymbols
        )
        {
            if (!candidates.TryGetValue(methodName, out var methodSymbols))
            {
                return false;
            }

            return methodSymbols.Any(methodSymbol =>
            {
                var comparer = SymbolEqualityComparer.Default;
                var targetParameterSymbols = methodSymbol.Parameters;

                if (parameterSymbols.Length != targetParameterSymbols.Length)
                {
                    return false;
                }

                for (var i = 0; i < targetParameterSymbols.Length; i++)
                {
                    var paramSymbol1 = parameterSymbols[i];
                    var paramSymbol2 = targetParameterSymbols[i];

                    if (!comparer.Equals(paramSymbol1.Type, paramSymbol2.Type))
                    {
                        return false;
                    }

                    if (paramSymbol1.RefKind != paramSymbol2.RefKind)
                    {
                        return false;
                    }

                    if (paramSymbol1.IsParams != paramSymbol2.IsParams)
                    {
                        return false;
                    }
                }

                return true;
            });
        }
        #endregion
    }

    private static (bool HasAttribute, string MethodName) GetTypeContext(INamedTypeSymbol? typeSymbol)
    {
        var attributeData = typeSymbol?
            .GetAttributes()
            .FirstOrDefault(attributeData => IsAutoFactoryAttribute(attributeData.AttributeClass));
        return (
            HasAttribute: attributeData != null,
            MethodName: TryGetGeneratedFactoryMethodName(attributeData, out var methodName)
                ? methodName
                : DefaultMethodName
        );
    }

    private static bool IsAutoFactoryAttribute(INamedTypeSymbol? symbol)
    {
        return symbol?.ToDisplayString() == AutoFactoryAttributeString;
    }

    private static bool IsIgnoreAutoFactoryAttribute(INamedTypeSymbol? symbol)
    {
        return symbol?.ToDisplayString() == IgnoreAutoFactoryAttributeString;
    }

    private static bool HasAutoFactoryAttribute(IMethodSymbol methodSymbol)
    {
        return methodSymbol.GetAttributes().Any(attributeData =>
        {
            return IsAutoFactoryAttribute(attributeData.AttributeClass);
        });
    }

    private static bool HasIgnoreAutoFactoryAttribute(IMethodSymbol methodSymbol)
    {
        return methodSymbol.GetAttributes().Any(attributeData =>
        {
            return IsIgnoreAutoFactoryAttribute(attributeData.AttributeClass);
        });
    }

    private static bool TryGetGeneratedFactoryMethodName(AttributeData? attributeData, out string methodName)
    {
        if (attributeData?.ConstructorArguments is [{ Value: string methodName2 }])
        {
            methodName = methodName2.Trim();
            return !string.IsNullOrEmpty(methodName);
        }
        else
        {
            methodName = "";
            return false;
        }
    }
    #endregion

    #region IIncrementalGenerator Interface
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource(
                hintName: "AutoFactoryAttribute.g.cs",
                sourceText: SourceText.From(AutoFactoryAttributeSource, Encoding.UTF8)
            );
            context.AddSource(
                hintName: "IgnoreAutoFactoryAttribute.g.cs",
                sourceText: SourceText.From(IgnoreAutoFactoryAttributeSource, Encoding.UTF8)
            );
        });

        var typeTargets = context
            .SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _) => syntaxNode is TypeDeclarationSyntax
                {
                    AttributeLists.Count: > 0
                },
                transform: static (generatorSyntaxContext, _) => GetTypeTarget(generatorSyntaxContext)
            )
            .Where(static namedTypeSymbol => namedTypeSymbol is not null);

        var constructorTargets = context
            .SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _) => syntaxNode is ConstructorDeclarationSyntax
                {
                    AttributeLists.Count: > 0
                },
                transform: static (generatorSyntaxContext, _) => GetConstructorTarget(generatorSyntaxContext)
            )
            .Where(static namedTypeSymbol => namedTypeSymbol is not null);


        var valueProvider = typeTargets.Collect().Combine(constructorTargets.Collect()).Select((tuple, _) =>
        {
            var (typeSymbols1, typeSymbols2) = tuple;
            return typeSymbols1
                .Concat(typeSymbols2)
                .Distinct(SymbolEqualityComparer.Default)
                .Cast<INamedTypeSymbol>()
                .ToImmutableArray();
        });

        context.RegisterSourceOutput(valueProvider, (sourceProductionContext, typeSymbols) =>
        {
            foreach (var typeSymbol in typeSymbols)
            {
                AddSource(sourceProductionContext, typeSymbol, GenerateFactoryMethodCode);
            }
        });
    }
    #endregion
}
