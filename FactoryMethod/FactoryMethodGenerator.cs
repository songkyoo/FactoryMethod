using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Security.Cryptography;
using System.Text;

namespace Macaron.FactoryMethod
{
    [Generator]
    public sealed class FactoryMethodGenerator : IIncrementalGenerator
    {
        #region Constants
        private const string GenerateFactoryMethodAttributeSource =
            """
            // <auto-generated/>
            using System;
            using System.Diagnostics;

            namespace Macaron.FactoryMethod
            {
                [Conditional("SOURCE_GENERATOR_ONLY")]
                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor, Inherited = false, AllowMultiple = false)]
                internal sealed class GenerateFactoryMethodAttribute : Attribute
                {
                    public string MethodName { get; }

                    public GenerateFactoryMethodAttribute()
                    {
                        MethodName = "";
                    }

                    public GenerateFactoryMethodAttribute(string methodName)
                    {
                        MethodName = methodName;
                    }
                }
            }
            """;

        private const string IgnoreFactoryMethodAttributeSource =
            """
            // <auto-generated/>
            using System;
            using System.Diagnostics;

            namespace Macaron.FactoryMethod
            {
                [Conditional("SOURCE_GENERATOR_ONLY")]
                [AttributeUsage(AttributeTargets.Constructor, Inherited = false, AllowMultiple = false)]
                internal sealed class IgnoreFactoryMethodAttribute : Attribute
                {
                }
            }
            """;

        private const string GenerateFactoryMethodAttributeDisplayString = "Macaron.FactoryMethod.GenerateFactoryMethodAttribute";
        private const string IgnoreFactoryMethodAttributeDisplayString = "Macaron.FactoryMethod.IgnoreFactoryMethodAttribute";
        #endregion

        #region Static
        private static void AddSource(
            SourceProductionContext context,
            INamedTypeSymbol typeSymbol,
            Func<INamedTypeSymbol, ImmutableArray<string>> generateSourceCode
        )
        {
            var lines = generateSourceCode(typeSymbol);
            if (lines.IsEmpty)
            {
                return;
            }

            var stringBuilder = CreateStringBuilderWithFileHeader();

            // begin namespace
            var hasNamespace = !typeSymbol.ContainingNamespace.IsGlobalNamespace;
            if (hasNamespace)
            {
                stringBuilder.AppendLine($"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                stringBuilder.AppendLine($"{{");
            }

            // get nestedTypes
            var nestedTypes = new List<INamedTypeSymbol>();
            var parentType = typeSymbol.ContainingType;
            while (parentType != null)
            {
                nestedTypes.Add(parentType);
                parentType = parentType.ContainingType;
            }

            var depthSpacerText = hasNamespace ? "    " : "";

            // begin nestedTypes
            for (var i = nestedTypes.Count - 1; i >= 0; --i)
            {
                var nestedType = nestedTypes[i];

                stringBuilder.AppendLine($"{depthSpacerText}{GetPartialTypeDeclarationString(nestedType)}");
                stringBuilder.AppendLine($"{depthSpacerText}{{");

                depthSpacerText += "    ";
            }

            // begin containingType
            stringBuilder.AppendLine($"{depthSpacerText}{GetPartialTypeDeclarationString(typeSymbol)}");
            stringBuilder.AppendLine($"{depthSpacerText}{{");

            // generate constructors
            depthSpacerText += "    ";

            foreach (var line in lines)
            {
                stringBuilder.AppendLine($"{(line.Length > 0 ? depthSpacerText : "")}{line}");
            }

            depthSpacerText = depthSpacerText[..^4];

            // end containedType
            stringBuilder.AppendLine($"{depthSpacerText}}}");

            // end nestedTypes
            for (var i = 0; i < nestedTypes.Count; ++i)
            {
                depthSpacerText = depthSpacerText[..^4];

                stringBuilder.AppendLine($"{depthSpacerText}}}");
            }

            // end namespace
            if (hasNamespace)
            {
                stringBuilder.AppendLine($"}}");
            }

            context.AddSource(
                hintName: GetHintName(typeSymbol),
                sourceText: SourceText.From(stringBuilder.ToString(), Encoding.UTF8)
            );

            #region Local Functions
            static StringBuilder CreateStringBuilderWithFileHeader()
            {
                var stringBuilder = new StringBuilder();
                stringBuilder.AppendLine("// <auto-generated />");
                stringBuilder.AppendLine("#nullable enable");
                stringBuilder.AppendLine();

                return stringBuilder;
            }

            static string GetPartialTypeDeclarationString(INamedTypeSymbol typeSymbol)
            {
                var typeKindString = GetTypeKindString(typeSymbol);
                var typeNameString = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

                return $"partial {typeKindString} {typeNameString}";
            }

            static string GetTypeKindString(INamedTypeSymbol typeSymbol)
            {
                if (typeSymbol.IsRecord)
                {
                    return "record";
                }

                return typeSymbol.TypeKind switch
                {
                    TypeKind.Class => "class",
                    TypeKind.Struct => "struct",
                    TypeKind.Interface => "interface",
                    _ => throw new InvalidOperationException($"Invalid type kind: {typeSymbol.TypeKind}")
                };
            }

            static string GetHintName(INamedTypeSymbol typeSymbol)
            {
                var assemblyName = typeSymbol.ContainingAssembly != null ? $"{typeSymbol.ContainingAssembly}," : "";
                var qualifiedName = typeSymbol.ToDisplayString();

                using var sha = SHA256.Create();
                var bytes = Encoding.UTF8.GetBytes(assemblyName + qualifiedName);
                var hash = sha.ComputeHash(bytes);
                var hashString = BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant()[..16];

                return $"{hashString}_{typeSymbol.Name}_{typeSymbol.Arity}.g.cs";
            }
            #endregion
        }

        private static ImmutableArray<string> GenerateSourceCode(INamedTypeSymbol symbol)
        {
            var (hasTypeLevelAttribute, methodBaseName) = GetBaseMethodsName(symbol);

            var constructorSymbols = symbol.InstanceConstructors
                .Where(methodSymbol =>
                {
                    return
                        methodSymbol.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal &&
                        !HasIgnoreFactoryMethodAttribute(methodSymbol);
                })
                .Where(methodSymbol => hasTypeLevelAttribute || HasGenerateFactoryMethodAttribute(methodSymbol))
                .ToList();

            var constructorSignatures = new List<string>();

            foreach (var methodSymbol in constructorSymbols)
            {
                var parameters = methodSymbol.Parameters;
                if (parameters.Length == 0)
                {
                    continue;
                }

                var paramList = string.Join(", ", parameters.Select(parameterSymbol =>
                {
                    var modifier = parameterSymbol.RefKind switch
                    {
                        RefKind.Ref => "ref ",
                        RefKind.Out => "out ",
                        RefKind.In => "in ",
                        _ => "",
                    };
                    var isParams = parameterSymbol.IsParams ? "params " : "";
                    var type = parameterSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var nullability =
                        parameterSymbol.NullableAnnotation == NullableAnnotation.Annotated && !type.EndsWith("?")
                        ? "?"
                        : "";
                    var name = GetCameCaseName(parameterSymbol.Name);

                    return $"{modifier}{isParams}{type}{nullability} {name}";
                }));
                var argList = string.Join(", ", parameters.Select(parameterSymbol =>
                {
                    var prefix = parameterSymbol.RefKind switch
                    {
                        RefKind.Ref => "ref ",
                        RefKind.Out => "out ",
                        RefKind.In => "in ",
                        _ => "",
                    };

                    return $"{prefix}{GetCameCaseName(parameterSymbol.Name)}";
                }));

                var attributeData = methodSymbol
                    .GetAttributes()
                    .FirstOrDefault(attributeData => IsGenerateFactoryMethodAttribute(attributeData.AttributeClass));
                var methodName = TryGetGeneratedFactoryMethodName(attributeData, out var methodName2)
                    ? methodName2
                    : methodBaseName;

                var method = $"{methodSymbol.DeclaredAccessibility.ToString().ToLowerInvariant()} static {symbol.Name} {methodName}({paramList}) => new({argList});";
                constructorSignatures.Add(method);
            }

            if (constructorSignatures.Count <= 0)
            {
                return ImmutableArray<string>.Empty;;
            }

            var builder = ImmutableArray.CreateBuilder<string>();
            foreach (var signature in constructorSignatures)
            {
                if (builder.Count > 0)
                {
                    builder.Add("");
                }

                builder.Add($"{signature}");
            }

            return builder.ToImmutable();

            #region Local Functions
            static bool HasGenerateFactoryMethodAttribute(IMethodSymbol methodSymbol)
            {
                return methodSymbol.GetAttributes().Any(attributeData => IsGenerateFactoryMethodAttribute(
                    attributeData.AttributeClass
                ));
            }

            static bool HasIgnoreFactoryMethodAttribute(IMethodSymbol methodSymbol)
            {
                return methodSymbol.GetAttributes().Any(attributeData => IsIgnoreFactoryMethodAttribute(
                    attributeData.AttributeClass
                ));
            }

            static string GetCameCaseName(string name)
            {
                return name.Length > 0 && char.IsLetter(name[0])
                    ? char.ToLowerInvariant(name[0]) + (name.Length > 1 ? name[1..] : "")
                    : name;
            }

            static (bool, string) GetBaseMethodsName(INamedTypeSymbol? typeSymbol)
            {
                var attributeData = typeSymbol?
                    .GetAttributes()
                    .FirstOrDefault(attributeData => IsGenerateFactoryMethodAttribute(attributeData.AttributeClass));
                return (
                    attributeData != null,
                    TryGetGeneratedFactoryMethodName(attributeData, out var methodName) ? methodName : "Of"
                );
            }

            static bool TryGetGeneratedFactoryMethodName(AttributeData? attributeData, out string methodName)
            {
                if (attributeData?.ConstructorArguments is [{ Value: string methodName2 }])
                {
                    methodName = methodName2;
                    return true;
                }
                else
                {
                    methodName = "";
                    return false;
                }
            }
            #endregion
        }

        private static bool IsGenerateFactoryMethodAttribute(INamedTypeSymbol? symbol)
        {
            return symbol?.ToDisplayString() == GenerateFactoryMethodAttributeDisplayString;
        }

        private static bool IsIgnoreFactoryMethodAttribute(INamedTypeSymbol? symbol)
        {
            return symbol?.ToDisplayString() == IgnoreFactoryMethodAttributeDisplayString;
        }
        #endregion

        #region IIncrementalGenerator Interface
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource(
                    hintName: "GenerateFactoryMethodAttributes.g.cs",
                    sourceText: SourceText.From(GenerateFactoryMethodAttributeSource, Encoding.UTF8)
                );
                ctx.AddSource(
                    hintName: "IgnoreFactoryMethodAttributes.g.cs",
                    sourceText: SourceText.From(IgnoreFactoryMethodAttributeSource, Encoding.UTF8)
                );
            });

            var typeTargets = context
                .SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => syntaxNode is TypeDeclarationSyntax
                    {
                        AttributeLists.Count: > 0
                    },
                    transform: static (generatorSyntaxContext, _) => GetTypeTarget(generatorSyntaxContext)
                )
                .Where(static namedTypeSymbol => namedTypeSymbol is not null);

            var constructorTargets = context
                .SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => syntaxNode is ConstructorDeclarationSyntax
                    {
                        AttributeLists.Count: > 0
                    },
                    transform: static (generatorSyntaxContext, _) => GetConstructorTarget(generatorSyntaxContext)
                )
                .Where(static namedTypeSymbol => namedTypeSymbol is not null);


            var valueProvider = typeTargets.Collect().Combine(constructorTargets.Collect()).Select((tuple, _) =>
            {
                var (typeSymbols1, typeSymbols2) = tuple;
                return typeSymbols1
                    .Concat(typeSymbols2)
                    .Distinct(SymbolEqualityComparer.Default)
                    .Cast<INamedTypeSymbol>()
                    .ToImmutableArray();
            });

            context.RegisterSourceOutput(valueProvider, (sourceProductionContext, typeSymbols) =>
            {
                foreach (var typeSymbol in typeSymbols)
                {
                    AddSource(sourceProductionContext, typeSymbol, GenerateSourceCode);
                }
            });

            #region Local Functions
            static INamedTypeSymbol? GetTypeTarget(GeneratorSyntaxContext context)
            {
                if (context.Node is not TypeDeclarationSyntax typeDeclarationSyntax)
                {
                    return null;
                }

                if (!GetAttributes(typeDeclarationSyntax)
                    .Select(GetMethodSymbol)
                    .Select(methodSymbol => methodSymbol?.ContainingType)
                    .Any(IsGenerateFactoryMethodAttribute)
                )
                {
                    return null;
                }

                return context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax);

                #region Local Functions
                static IEnumerable<AttributeSyntax> GetAttributes(TypeDeclarationSyntax typeDeclarationSyntax)
                {
                    return typeDeclarationSyntax.AttributeLists.SelectMany(attrList => attrList.Attributes);
                }

                IMethodSymbol? GetMethodSymbol(AttributeSyntax attributeSyntax)
                {
                    return context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;
                }
                #endregion
            }

            static INamedTypeSymbol? GetConstructorTarget(GeneratorSyntaxContext context)
            {
                var node = (ConstructorDeclarationSyntax)context.Node;
                return context.SemanticModel.GetDeclaredSymbol(node)?.ContainingType;
            }
            #endregion
        }
        #endregion
    }
}
